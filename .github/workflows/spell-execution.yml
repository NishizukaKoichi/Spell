name: Spell Execution

on:
  workflow_dispatch:
    inputs:
      cast_id:
        description: "Cast ID from database"
        required: true
        type: string
      spell_key:
        description: "Spell key to execute"
        required: true
        type: string
      input_data:
        description: "Input data as JSON string"
        required: false
        type: string
        default: "{}"
      code_url:
        description: "URL to download spell code from R2"
        required: false
        type: string
      runtime:
        description: "Runtime type (wasm, node, python, deno)"
        required: false
        type: string

jobs:
  execute:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Parse input data
        id: parse
        run: |
          echo "cast_id=${{ github.event.inputs.cast_id }}" >> $GITHUB_OUTPUT
          echo "spell_key=${{ github.event.inputs.spell_key }}" >> $GITHUB_OUTPUT
          echo 'input_data=${{ github.event.inputs.input_data }}' >> $GITHUB_OUTPUT
          echo "code_url=${{ github.event.inputs.code_url }}" >> $GITHUB_OUTPUT
          echo "runtime=${{ github.event.inputs.runtime }}" >> $GITHUB_OUTPUT

      - name: Download spell code
        if: ${{ github.event.inputs.code_url != '' }}
        run: |
          echo "Downloading spell code from: ${{ steps.parse.outputs.code_url }}"
          mkdir -p spell-code
          curl -o spell-code/code "${{ steps.parse.outputs.code_url }}"
          ls -lah spell-code/

      - name: Setup Node.js
        if: ${{ github.event.inputs.runtime == 'node' || github.event.inputs.runtime == 'nodejs' }}
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Python
        if: ${{ github.event.inputs.runtime == 'python' }}
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Setup Deno
        if: ${{ github.event.inputs.runtime == 'deno' }}
        uses: denoland/setup-deno@v1
        with:
          deno-version: v1.x

      - name: Execute spell
        id: execute
        run: |
          echo "Executing spell: ${{ steps.parse.outputs.spell_key }}"
          echo "Cast ID: ${{ steps.parse.outputs.cast_id }}"
          echo "Runtime: ${{ steps.parse.outputs.runtime }}"
          echo "Input data: ${{ steps.parse.outputs.input_data }}"

          mkdir -p output

          # Save input data to file for runtime to read
          echo '${{ steps.parse.outputs.input_data }}' > input.json

          # Execute based on runtime
          if [ "${{ steps.parse.outputs.runtime }}" == "node" ] || [ "${{ steps.parse.outputs.runtime }}" == "nodejs" ]; then
            echo "Executing Node.js spell..."
            node spell-code/code > output/result.txt 2>&1 || echo "Execution failed" > output/result.txt

          elif [ "${{ steps.parse.outputs.runtime }}" == "python" ]; then
            echo "Executing Python spell..."
            python3 spell-code/code > output/result.txt 2>&1 || echo "Execution failed" > output/result.txt

          elif [ "${{ steps.parse.inputs.runtime }}" == "deno" ]; then
            echo "Executing Deno spell..."
            deno run --allow-read --allow-write spell-code/code > output/result.txt 2>&1 || echo "Execution failed" > output/result.txt

          elif [ "${{ steps.parse.outputs.runtime }}" == "wasm" ]; then
            echo "Executing WASM spell..."
            # Note: WASM execution requires a runtime like wasmtime
            # Install wasmtime
            curl https://wasmtime.dev/install.sh -sSf | bash
            export PATH="$HOME/.wasmtime/bin:$PATH"
            wasmtime spell-code/code > output/result.txt 2>&1 || echo "Execution failed" > output/result.txt

          else
            # No code provided - create placeholder output
            echo "No spell code provided - creating placeholder output"
            echo "Mock output for spell ${{ steps.parse.outputs.spell_key }}" > output/result.txt
            echo "Executed at: $(date)" >> output/result.txt
          fi

          echo "Execution complete"
          cat output/result.txt

      - name: Upload artifact to R2
        id: upload
        env:
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CLOUDFLARE_R2_ACCESS_KEY_ID: ${{ secrets.CLOUDFLARE_R2_ACCESS_KEY_ID }}
          CLOUDFLARE_R2_SECRET_ACCESS_KEY: ${{ secrets.CLOUDFLARE_R2_SECRET_ACCESS_KEY }}
          CLOUDFLARE_R2_BUCKET_NAME: ${{ secrets.CLOUDFLARE_R2_BUCKET_NAME }}
        run: |
          # Install AWS CLI for R2 (S3-compatible)
          pip install awscli

          # Configure AWS CLI for R2
          aws configure set aws_access_key_id $CLOUDFLARE_R2_ACCESS_KEY_ID
          aws configure set aws_secret_access_key $CLOUDFLARE_R2_SECRET_ACCESS_KEY
          aws configure set region auto

          # Upload to R2
          ARTIFACT_KEY="casts/${{ steps.parse.outputs.cast_id }}/result.txt"
          aws s3 cp output/result.txt \
            "s3://$CLOUDFLARE_R2_BUCKET_NAME/$ARTIFACT_KEY" \
            --endpoint-url "https://$CLOUDFLARE_ACCOUNT_ID.r2.cloudflarestorage.com"

          ARTIFACT_URL="https://$CLOUDFLARE_ACCOUNT_ID.r2.cloudflarestorage.com/$CLOUDFLARE_R2_BUCKET_NAME/$ARTIFACT_KEY"
          echo "artifact_url=$ARTIFACT_URL" >> $GITHUB_OUTPUT

      - name: Update cast status
        env:
          API_URL: ${{ secrets.API_URL }}
          API_SECRET: ${{ secrets.API_SECRET }}
        run: |
          # Calculate duration
          DURATION=$SECONDS

          # Update cast in database via API
          curl -X PATCH "$API_URL/api/casts/${{ steps.parse.outputs.cast_id }}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_SECRET" \
            -d "{
              \"status\": \"completed\",
              \"finishedAt\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
              \"duration\": $DURATION,
              \"artifactUrl\": \"${{ steps.upload.outputs.artifact_url }}\"
            }"

      - name: Update cast status on failure
        if: failure()
        env:
          API_URL: ${{ secrets.API_URL }}
          API_SECRET: ${{ secrets.API_SECRET }}
        run: |
          curl -X PATCH "$API_URL/api/casts/${{ steps.parse.outputs.cast_id }}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_SECRET" \
            -d "{
              \"status\": \"failed\",
              \"finishedAt\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
              \"errorMessage\": \"Workflow execution failed\"
            }"
