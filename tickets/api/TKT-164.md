# [TKT-164] POST /v1/spells/{id}:cast (Cast Spell)

## 目的
Spellを実行する中核APIエンドポイント。Budget Cap、Idempotency、実行モード選択を統合。

## スコープ
- `/src/app/api/v1/spells/[id]/cast/route.ts`
- `/src/lib/execution/orchestrator.ts`

## 実装詳細

### SPEC-Platform.md セクション参照
- Section 15: Endpoints
- Section 4: 実行フロー（ユーザー視点）

### SPEC-Implementation.md セクション参照
- Section 5: Public API（要旨）
- Section 4: 実行フロー（ユーザー視点）

### API Implementation

```typescript
// route.ts
import { NextRequest } from 'next/server';
import { authenticateRequest } from '@/middleware/auth';
import { rateLimitMiddleware, RATE_LIMITS } from '@/middleware/rate-limit';
import { idempotencyMiddleware } from '@/middleware/idempotency';
import { budgetCheckMiddleware } from '@/middleware/budget-check';
import { CastOrchestrator } from '@/lib/execution/orchestrator';
import { ErrorCatalog, handleError } from '@/lib/errors';
import { z } from 'zod';

const CastRequestSchema = z.object({
  inputs: z.record(z.any()),
  mode: z.enum(['workflow', 'service', 'clone']).optional(),
  budget_cap: z.number().int().positive().optional()
});

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. Authentication
    const auth = await authenticateRequest(req);
    if (!auth) {
      throw ErrorCatalog.UNAUTHORIZED();
    }

    // 2. Rate limiting
    const rateLimitError = await rateLimitMiddleware(RATE_LIMITS.cast)(req, auth);
    if (rateLimitError) {
      return rateLimitError;
    }

    // 3. Idempotency
    const idempotencyError = await idempotencyMiddleware()(req, auth);
    if (idempotencyError) {
      return idempotencyError;
    }

    // 4. Parse request
    const body = await req.json();
    const validated = CastRequestSchema.parse(body);

    // 5. Get spell
    const spell = await prisma.spell.findUnique({
      where: { key: params.id }
    });

    if (!spell) {
      throw ErrorCatalog.SPELL_NOT_FOUND(params.id);
    }

    if (spell.status !== 'published') {
      throw ErrorCatalog.FORBIDDEN('Spell is not published');
    }

    // 6. Estimate cost
    const estimatedCostCents = await estimateCost(spell, validated.inputs);

    // 7. Budget check
    const budgetResult = await budgetCheckMiddleware(
      req,
      auth,
      estimatedCostCents
    );

    // 8. Create cast record
    const cast = await prisma.cast.create({
      data: {
        spellKey: spell.key,
        spellVersion: spell.version,
        casterId: auth.user_id,
        inputHash: hashInputs(validated.inputs),
        mode: validated.mode || spell.executionMode,
        status: 'queued',
        idempotencyKey: req.headers.get('X-Idempotency-Key')!,
        costCents: estimatedCostCents
      }
    });

    // 9. Execute via orchestrator
    const orchestrator = new CastOrchestrator();
    const execution = await orchestrator.execute({
      castId: cast.id,
      spell,
      inputs: validated.inputs,
      mode: cast.mode as ExecutionMode,
      userId: auth.user_id
    });

    // 10. Store idempotency result
    const response = {
      cast_id: cast.id,
      status: cast.status,
      run_url: execution.run_url,
      progress_sse: `/v1/casts/${cast.id}/events`,
      estimated_cost_cents: estimatedCostCents,
      budget_remaining: budgetResult.remaining
    };

    await storeIdempotencyResult(
      req.headers.get('X-Idempotency-Key')!,
      auth.user_id,
      response
    );

    return new Response(JSON.stringify(response), {
      status: 202, // Accepted
      headers: {
        'Content-Type': 'application/json',
        'Location': `/v1/casts/${cast.id}`
      }
    });
  } catch (error) {
    return handleError(error);
  }
}

function hashInputs(inputs: Record<string, any>): string {
  const canonical = JSON.stringify(inputs, Object.keys(inputs).sort());
  return createHash('sha256').update(canonical).digest('hex');
}

async function estimateCost(spell: any, inputs: any): Promise<number> {
  // Simple estimation based on pricing model
  if (spell.pricingModel === 'flat') {
    return spell.pricingConfig.flat_cents || 0;
  }

  if (spell.pricingModel === 'metered') {
    // Estimate based on input size, etc.
    const inputSize = JSON.stringify(inputs).length;
    const baseCents = spell.pricingConfig.base_cents || 0;
    const perKB = spell.pricingConfig.metered?.price_per_unit_cents || 0;
    return baseCents + Math.ceil(inputSize / 1024) * perKB;
  }

  return 0;
}
```

### Orchestrator

```typescript
// orchestrator.ts
import { WorkflowExecutor } from './workflow';
import { ServiceExecutor } from './service';
import { CloneExecutor } from './clone';

export interface ExecutionRequest {
  castId: string;
  spell: any;
  inputs: Record<string, any>;
  mode: ExecutionMode;
  userId: string;
}

export interface ExecutionResult {
  run_url?: string;
  artifact_url?: string;
  status: string;
}

export class CastOrchestrator {
  async execute(req: ExecutionRequest): Promise<ExecutionResult> {
    switch (req.mode) {
      case 'workflow':
        return await this.executeWorkflow(req);
      case 'service':
        return await this.executeService(req);
      case 'clone':
        return await this.executeClone(req);
      default:
        throw new Error(`Unknown execution mode: ${req.mode}`);
    }
  }

  private async executeWorkflow(req: ExecutionRequest): Promise<ExecutionResult> {
    const executor = new WorkflowExecutor(
      await getInstallationToken(req.spell.executionConfig.repo)
    );

    const run = await executor.execute(
      req.spell.executionConfig,
      req.inputs,
      req.castId
    );

    await prisma.cast.update({
      where: { id: req.castId },
      data: {
        status: 'running',
        runUrl: run.url,
        startedAt: new Date()
      }
    });

    return {
      run_url: run.url,
      status: 'running'
    };
  }

  private async executeService(req: ExecutionRequest): Promise<ExecutionResult> {
    const executor = new ServiceExecutor();

    await executor.enqueue({
      castId: req.castId,
      spellKey: req.spell.key,
      inputs: req.inputs,
      config: req.spell.executionConfig
    });

    await prisma.cast.update({
      where: { id: req.castId },
      data: {
        status: 'queued'
      }
    });

    return {
      status: 'queued'
    };
  }

  private async executeClone(req: ExecutionRequest): ExecutionResult {
    // Clone mode requires payment first
    throw ErrorCatalog.PAYMENT_REQUIRED(
      'Clone mode requires one-time payment. Use /catalog/spells/{id}/purchase'
    );
  }
}
```

## 受け入れ条件
- [ ] POST /v1/spells/{id}:cast endpoint
- [ ] Authentication middleware applied
- [ ] Rate limiting applied (100/hour)
- [ ] Idempotency-Key required and enforced
- [ ] Budget cap pre-check (402 on exceed)
- [ ] Input validation with Zod
- [ ] Cost estimation logic
- [ ] Cast record creation
- [ ] Orchestrator delegates to correct executor
- [ ] 202 Accepted response
- [ ] SSE progress URL returned
- [ ] Tests with all execution modes
- [ ] Tests with budget scenarios
- [ ] Tests with duplicate idempotency keys
- [ ] Tests pass locally
- [ ] Code committed

## 依存関係
blocks: [TKT-165, TKT-166, TKT-204, TKT-205]
blocked-by: [TKT-001-005, TKT-061, TKT-062, TKT-087]

## 技術スタック
- Next.js App Router
- Prisma
- Zod validation
- TypeScript

## 優先度
CRITICAL

## 見積もり複雑度
L (Large)

## セキュリティ考慮事項
- Input sanitization (JSON Schema validation)
- Input stored as hash only (privacy)
- Budget cap enforcement (prevent runaway costs)
- Idempotency prevents duplicate charges
- Rate limiting prevents abuse
- RBAC: caster role required
