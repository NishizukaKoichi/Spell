# [TKT-061] Workflow Mode (GitHub Actions Dispatch)

## 目的

GitHub Actions の workflow_dispatch / repository_dispatch を使用してSpellを実行するモードを実装。

## スコープ

- `/src/lib/execution/workflow.ts`
- `/src/lib/github/client.ts`

## 実装詳細

### SPEC-Platform.md セクション参照

- Section 2.1: Execution Modes

### SPEC-Implementation.md セクション参照

- Section 2.1: モード定義（必須）
- Section 6.1: GitHub Actions 側サンプル

### ワークフロー実行

```typescript
// workflow.ts
import { Octokit } from '@octokit/rest';

export interface WorkflowExecution {
  repo: string; // owner/name
  workflow_id: string; // spell.yml or workflow ID
  dispatch: 'workflow_dispatch' | 'repository_dispatch';
}

export class WorkflowExecutor {
  private octokit: Octokit;

  constructor(installationToken: string) {
    this.octokit = new Octokit({ auth: installationToken });
  }

  async execute(
    exec: WorkflowExecution,
    inputs: Record<string, any>,
    castId: string
  ): Promise<WorkflowRun> {
    const [owner, repo] = exec.repo.split('/');

    if (exec.dispatch === 'workflow_dispatch') {
      return await this.workflowDispatch(owner, repo, exec.workflow_id, inputs, castId);
    } else {
      return await this.repositoryDispatch(owner, repo, inputs, castId);
    }
  }

  private async workflowDispatch(
    owner: string,
    repo: string,
    workflowId: string,
    inputs: Record<string, any>,
    castId: string
  ): Promise<WorkflowRun> {
    // 1. Check if workflow exists
    const workflows = await this.octokit.actions.listRepoWorkflows({
      owner,
      repo,
    });

    const workflow = workflows.data.workflows.find(
      (w) => w.path.includes(workflowId) || w.id.toString() === workflowId
    );

    if (!workflow) {
      throw new Error(`Workflow ${workflowId} not found in ${owner}/${repo}`);
    }

    // 2. Dispatch workflow
    await this.octokit.actions.createWorkflowDispatch({
      owner,
      repo,
      workflow_id: workflow.id,
      ref: 'main', // or configurable
      inputs: {
        payload: JSON.stringify(inputs),
        cast_id: castId,
      },
    });

    // 3. Poll for workflow run
    const run = await this.waitForWorkflowRun(owner, repo, workflow.id, castId);

    return {
      id: run.id,
      url: run.html_url,
      status: this.mapStatus(run.status),
      conclusion: run.conclusion,
    };
  }

  private async repositoryDispatch(
    owner: string,
    repo: string,
    inputs: Record<string, any>,
    castId: string
  ): Promise<WorkflowRun> {
    // Dispatch event
    await this.octokit.repos.createDispatchEvent({
      owner,
      repo,
      event_type: 'spell.cast',
      client_payload: {
        ...inputs,
        cast_id: castId,
      },
    });

    // Poll for workflow run (check recent runs)
    const run = await this.waitForDispatchRun(owner, repo, castId);

    return {
      id: run.id,
      url: run.html_url,
      status: this.mapStatus(run.status),
      conclusion: run.conclusion,
    };
  }

  private async waitForWorkflowRun(
    owner: string,
    repo: string,
    workflowId: number,
    castId: string,
    maxWaitMs = 60000 // 1 minute
  ): Promise<any> {
    const startTime = Date.now();

    while (Date.now() - startTime < maxWaitMs) {
      const runs = await this.octokit.actions.listWorkflowRuns({
        owner,
        repo,
        workflow_id: workflowId,
        per_page: 10,
      });

      // Find run with matching cast_id in inputs
      // This requires workflow to echo cast_id somehow
      const run = runs.data.workflow_runs[0]; // Latest run

      if (run && Date.now() - new Date(run.created_at).getTime() < 10000) {
        return run;
      }

      await this.sleep(2000); // Poll every 2s
    }

    throw new Error('Workflow run not found within timeout');
  }

  private async waitForDispatchRun(
    owner: string,
    repo: string,
    castId: string,
    maxWaitMs = 60000
  ): Promise<any> {
    const startTime = Date.now();

    while (Date.now() - startTime < maxWaitMs) {
      const runs = await this.octokit.actions.listWorkflowRunsForRepo({
        owner,
        repo,
        event: 'repository_dispatch',
        per_page: 10,
      });

      const run = runs.data.workflow_runs[0];

      if (run && Date.now() - new Date(run.created_at).getTime() < 10000) {
        return run;
      }

      await this.sleep(2000);
    }

    throw new Error('Dispatch run not found within timeout');
  }

  private mapStatus(status: string): string {
    const mapping: Record<string, string> = {
      queued: 'queued',
      in_progress: 'running',
      completed: 'completed',
    };
    return mapping[status] || 'unknown';
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}

export interface WorkflowRun {
  id: number;
  url: string;
  status: string;
  conclusion: string | null;
}
```

## 受け入れ条件

- [ ] workflow_dispatch implementation
- [ ] repository_dispatch implementation
- [ ] Workflow existence check
- [ ] Repository permission check
- [ ] Run polling with timeout
- [ ] Status mapping (queued/running/completed)
- [ ] Error handling (workflow not found, permission denied)
- [ ] Tests with real GitHub Actions
- [ ] Tests pass locally
- [ ] Code committed

## 依存関係

blocks: [TKT-064, TKT-066, TKT-068, TKT-164]
blocked-by: [TKT-001, TKT-005]

## 技術スタック

- Octokit (GitHub API)
- GitHub Actions API
- Polling strategy

## 優先度

CRITICAL

## 見積もり複雑度

L (Large)

## セキュリティ考慮事項

- Installation token (short-lived)
- Repository permission validation
- Input sanitization (JSON serialization)
- Rate limiting on GitHub API
