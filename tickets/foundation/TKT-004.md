# [TKT-004] Rate Limiting (Redis-backed)

## 目的

Redis を使用した分散レート制限を実装し、API濫用を防止。

## スコープ

- `/src/middleware/rate-limit.ts`
- `/src/lib/redis.ts`

## 実装詳細

### SPEC-Platform.md セクション参照

- Section 17: Backpressure & Rate Limiting

### SPEC-Implementation.md セクション参照

- Section 24: エラーコード (RATE_LIMITED)

### アルゴリズム

**Token Bucket** または **Sliding Window** を使用。

```typescript
// rate-limit.ts
import { Redis } from '@upstash/redis';

export interface RateLimitConfig {
  limit: number; // requests per window
  window: number; // seconds
}

export interface RateLimitResult {
  allowed: boolean;
  limit: number;
  remaining: number;
  reset: number; // Unix timestamp
}

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_URL!,
  token: process.env.UPSTASH_REDIS_TOKEN!,
});

export async function checkRateLimit(
  key: string, // user_id or api_key
  config: RateLimitConfig
): Promise<RateLimitResult> {
  const now = Math.floor(Date.now() / 1000);
  const windowKey = `ratelimit:${key}:${Math.floor(now / config.window)}`;

  const pipeline = redis.pipeline();
  pipeline.incr(windowKey);
  pipeline.expire(windowKey, config.window * 2); // Keep for 2 windows

  const [count] = (await pipeline.exec()) as [number, string];

  const allowed = count <= config.limit;
  const reset = (Math.floor(now / config.window) + 1) * config.window;

  return {
    allowed,
    limit: config.limit,
    remaining: Math.max(0, config.limit - count),
    reset,
  };
}

export function rateLimitMiddleware(config: RateLimitConfig) {
  return async (req: NextRequest, ctx: AuthContext) => {
    const key = ctx.user_id || req.ip || 'anonymous';
    const result = await checkRateLimit(key, config);

    // Add headers
    const headers = new Headers();
    headers.set('X-RateLimit-Limit', result.limit.toString());
    headers.set('X-RateLimit-Remaining', result.remaining.toString());
    headers.set('X-RateLimit-Reset', result.reset.toString());

    if (!result.allowed) {
      const retryAfter = result.reset - Math.floor(Date.now() / 1000);
      headers.set('Retry-After', retryAfter.toString());

      return new Response(
        JSON.stringify({
          error: {
            code: 'RATE_LIMITED',
            message: 'Rate limit exceeded',
            retry_after: retryAfter,
          },
        }),
        {
          status: 429,
          headers: {
            'Content-Type': 'application/json',
            ...Object.fromEntries(headers.entries()),
          },
        }
      );
    }

    // Attach headers to response (downstream)
    req.headers.set('X-RateLimit-Info', JSON.stringify(result));
    return null; // Allow request
  };
}
```

### レート制限設定例

```typescript
export const RATE_LIMITS = {
  // Per API key
  api: {
    limit: 1000,
    window: 3600, // 1000 req/hour
  },
  // Per IP (anonymous)
  anonymous: {
    limit: 10,
    window: 60, // 10 req/min
  },
  // Cast endpoint (authenticated)
  cast: {
    limit: 100,
    window: 3600, // 100 casts/hour
  },
};
```

## 受け入れ条件

- [ ] Redis connection configured
- [ ] Token bucket or sliding window implemented
- [ ] Rate limit headers (`X-RateLimit-*`) returned
- [ ] 429 status with `Retry-After` on limit exceeded
- [ ] Different limits for different endpoints
- [ ] IP-based limiting for anonymous requests
- [ ] Tests pass locally
- [ ] Code committed

## 依存関係

blocks: [TKT-005, TKT-161]
blocked-by: [TKT-001, TKT-003]

## 技術スタック

- Redis (Upstash or self-hosted)
- Token Bucket / Sliding Window algorithm
- Next.js middleware

## 優先度

HIGH

## 見積もり複雑度

M (Medium)

## セキュリティ考慮事項

- Prevent DDoS attacks
- Different limits for authenticated vs anonymous
- Graceful degradation on Redis failure
- Rate limit bypass for internal services
