# [TKT-005] Idempotency Handling

## 目的

Idempotency-Key を使用して、重複リクエストの安全な再試行を保証。

## スコープ

- `/src/middleware/idempotency.ts`
- `/src/lib/idempotency.ts`

## 実装詳細

### SPEC-Platform.md セクション参照

- Section 13: REST API Overview (implicit)
- Section 23: Budget Controls (idempotency for billing)

### SPEC-Implementation.md セクション参照

- Section 7.3: Idempotency / 返金
- Section 21.2: MCP Tools (idempotency_key in spells.cast)

### 実装

```typescript
// idempotency.ts
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_URL!,
  token: process.env.UPSTASH_REDIS_TOKEN!,
});

export interface IdempotencyResult {
  is_duplicate: boolean;
  original_response?: any;
}

const IDEMPOTENCY_TTL = 86400; // 24 hours

export async function checkIdempotency(key: string, userId: string): Promise<IdempotencyResult> {
  const redisKey = `idempotency:${userId}:${key}`;
  const cached = await redis.get(redisKey);

  if (cached) {
    return {
      is_duplicate: true,
      original_response: JSON.parse(cached as string),
    };
  }

  return {
    is_duplicate: false,
  };
}

export async function storeIdempotencyResult(
  key: string,
  userId: string,
  response: any
): Promise<void> {
  const redisKey = `idempotency:${userId}:${key}`;
  await redis.setex(redisKey, IDEMPOTENCY_TTL, JSON.stringify(response));
}

export function idempotencyMiddleware() {
  return async (req: NextRequest, ctx: AuthContext) => {
    // Only for mutating operations
    if (!['POST', 'PUT', 'PATCH', 'DELETE'].includes(req.method)) {
      return null;
    }

    const idempotencyKey = req.headers.get('idempotency-key');

    if (!idempotencyKey) {
      // Require idempotency key for critical operations
      const path = new URL(req.url).pathname;
      if (path.includes('/cast') || path.includes('/billing')) {
        return new Response(
          JSON.stringify({
            error: {
              code: 'IDEMPOTENCY_KEY_REQUIRED',
              message: 'Idempotency-Key header is required for this operation',
            },
          }),
          { status: 400, headers: { 'Content-Type': 'application/json' } }
        );
      }
      return null;
    }

    // Check for duplicate
    const result = await checkIdempotency(idempotencyKey, ctx.user_id);

    if (result.is_duplicate) {
      // Return cached response
      return new Response(JSON.stringify(result.original_response), {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          'Idempotent-Replayed': 'true',
        },
      });
    }

    // Store request context for later
    req.headers.set('X-Idempotency-Key', idempotencyKey);
    return null; // Allow request to proceed
  };
}

// Usage in cast endpoint
export async function handleCastRequest(req: NextRequest, ctx: AuthContext) {
  const idempotencyKey = req.headers.get('X-Idempotency-Key');

  try {
    // Process cast...
    const result = await processCast(/* ... */);

    // Store result for idempotency
    if (idempotencyKey) {
      await storeIdempotencyResult(idempotencyKey, ctx.user_id, result);
    }

    return result;
  } catch (error) {
    // On error, we don't store idempotency result
    // Client can retry with same key
    throw error;
  }
}
```

## 受け入れ条件

- [ ] Idempotency-Key header validation
- [ ] Redis-based storage (24h TTL)
- [ ] Duplicate detection returns cached response
- [ ] `Idempotent-Replayed` header on duplicates
- [ ] Required for cast and billing endpoints
- [ ] Error responses NOT cached
- [ ] Tests with duplicate requests
- [ ] Tests pass locally
- [ ] Code committed

## 依存関係

blocks: [TKT-061, TKT-081]
blocked-by: [TKT-001, TKT-003, TKT-004]

## 技術スタック

- Redis (Upstash)
- Next.js middleware
- JSON serialization

## 優先度

HIGH

## 見積もり複雑度

S (Small)

## セキュリティ考慮事項

- Keys scoped per user to prevent cross-user replay
- TTL prevents indefinite storage
- Only successful responses cached
- Error responses allow retry
