# [TKT-003] API Authentication Middleware

## 目的

GitHub OAuth & API Key認証を実装し、すべてのAPIエンドポイントで認証を強制。

## スコープ

- `/src/middleware/auth.ts`
- `/src/lib/auth/github.ts`
- `/src/lib/auth/api-key.ts`

## 実装詳細

### SPEC-Platform.md セクション参照

- Section 14: Authentication
- Section 19: Key Lifecycle Management

### SPEC-Implementation.md セクション参照

- Section 12: 必須 Secrets（例）
- Section 17: 役割/RBAC

### 認証フロー

**GitHub OAuth (Browser/UI):**

1. User clicks "Sign in with GitHub"
2. Redirect to GitHub OAuth
3. Exchange code for access token
4. Create/update user in DB
5. Issue session token (JWT or session cookie)

**API Key (CLI/SDK/Programmatic):**

1. User generates API key in dashboard
2. Key is hashed and stored in DB
3. Client sends `Authorization: Bearer <key>`
4. Middleware validates key hash
5. Attach user context to request

```typescript
// auth.ts
import { NextRequest } from 'next/server';
import { createHash } from 'crypto';

export interface AuthContext {
  user_id: string;
  role: string;
  scopes: string[];
}

export async function authenticateRequest(req: NextRequest): Promise<AuthContext | null> {
  const authHeader = req.headers.get('authorization');

  if (!authHeader) {
    return null;
  }

  // API Key auth
  if (authHeader.startsWith('Bearer sk_')) {
    const apiKey = authHeader.replace('Bearer ', '');
    return await authenticateApiKey(apiKey);
  }

  // Session auth (for browser/UI)
  if (authHeader.startsWith('Bearer ey')) {
    return await authenticateSession(authHeader.replace('Bearer ', ''));
  }

  return null;
}

async function authenticateApiKey(key: string): Promise<AuthContext | null> {
  const keyHash = createHash('sha256').update(key).digest('hex');

  const apiKey = await prisma.apiKey.findUnique({
    where: { keyHash },
    include: { user: true },
  });

  if (!apiKey || apiKey.status !== 'active') {
    return null;
  }

  if (apiKey.expiresAt && new Date() > apiKey.expiresAt) {
    return null;
  }

  // Update last used
  await prisma.apiKey.update({
    where: { id: apiKey.id },
    data: { lastUsedAt: new Date() },
  });

  return {
    user_id: apiKey.userId,
    role: apiKey.user.role,
    scopes: apiKey.scopes,
  };
}

export function requireAuth(scopes?: string[]) {
  return async (req: NextRequest, ctx: AuthContext) => {
    if (!ctx) {
      return new Response(
        JSON.stringify({
          error: {
            code: 'UNAUTHORIZED',
            message: 'Authentication required',
          },
        }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (scopes && scopes.length > 0) {
      const hasScope = scopes.some((s) => ctx.scopes.includes(s));
      if (!hasScope) {
        return new Response(
          JSON.stringify({
            error: {
              code: 'FORBIDDEN',
              message: 'Insufficient permissions',
            },
          }),
          { status: 403, headers: { 'Content-Type': 'application/json' } }
        );
      }
    }

    return null; // Allow request
  };
}
```

## 受け入れ条件

- [ ] GitHub OAuth flow implemented
- [ ] API key generation & validation
- [ ] Key hashing with SHA-256
- [ ] Scope-based authorization
- [ ] Session management (JWT or cookie)
- [ ] Middleware applied to all API routes
- [ ] Rate limiting per user/key
- [ ] Tests pass locally
- [ ] Code committed

## 依存関係

blocks: [TKT-005, TKT-161, TKT-162]
blocked-by: [TKT-001, TKT-002]

## 技術スタック

- NextAuth.js or custom OAuth
- SHA-256 for key hashing
- JWT or session cookies
- Prisma

## 優先度

CRITICAL

## 見積もり複雑度

M (Medium)

## セキュリティ考慮事項

- API keys never stored in plaintext
- Short-lived tokens preferred
- Scopes strictly enforced
- Key rotation supported
- Audit trail for key usage
