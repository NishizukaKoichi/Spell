# [TKT-023] SBOM Validation Service

## 目的
アップロードされたSpellのSBOMを検証し、脆弱性スキャンとライセンス互換性チェックを実行。

## スコープ
- `/src/lib/sbom/validator.ts`
- `/src/lib/sbom/cve-scanner.ts`
- `/src/lib/sbom/license-checker.ts`

## 実装詳細

### SPEC-Platform.md セクション参照
- Section 9.4.3: SBOM Validation (Platform側)
- Section 9.3.1: Dependency Scanning

### 検証ロジック

```typescript
// validator.ts
import { SPDX } from '@/types/spdx';

export interface SBOMValidationResult {
  valid: boolean;
  issues: ValidationIssue[];
  warnings: ValidationIssue[];
  package_count: number;
  high_severity_vulns: number;
  medium_severity_vulns: number;
}

export interface ValidationIssue {
  severity: 'critical' | 'high' | 'medium' | 'low';
  message: string;
  package?: string;
  cve_id?: string;
}

export class SBOMValidator {
  async validate(sbomJson: string): Promise<SBOMValidationResult> {
    const sbom: SPDX = JSON.parse(sbomJson);
    const issues: ValidationIssue[] = [];
    const warnings: ValidationIssue[] = [];

    // 1. Format validation
    if (!sbom.spdxVersion || !['SPDX-2.2', 'SPDX-2.3'].includes(sbom.spdxVersion)) {
      issues.push({
        severity: 'critical',
        message: `Invalid SPDX version: ${sbom.spdxVersion}`
      });
    }

    // 2. Completeness check
    if (!sbom.packages || sbom.packages.length === 0) {
      issues.push({
        severity: 'critical',
        message: 'SBOM contains no packages'
      });
      return {
        valid: false,
        issues,
        warnings,
        package_count: 0,
        high_severity_vulns: 0,
        medium_severity_vulns: 0
      };
    }

    // 3. CVE scanning
    const cveScanner = new CVEScanner();
    for (const pkg of sbom.packages) {
      const vulns = await cveScanner.scanPackage(
        pkg.name,
        pkg.versionInfo
      );

      for (const vuln of vulns) {
        if (vuln.cvss >= 7.0) {
          issues.push({
            severity: vuln.cvss >= 9.0 ? 'critical' : 'high',
            message: `${pkg.name}@${pkg.versionInfo}: ${vuln.id} (CVSS ${vuln.cvss})`,
            package: pkg.name,
            cve_id: vuln.id
          });
        } else if (vuln.cvss >= 5.0) {
          warnings.push({
            severity: 'medium',
            message: `${pkg.name}@${pkg.versionInfo}: ${vuln.id} (CVSS ${vuln.cvss})`,
            package: pkg.name,
            cve_id: vuln.id
          });
        }
      }
    }

    // 4. License compatibility
    const licenseChecker = new LicenseChecker();
    for (const pkg of sbom.packages) {
      if (pkg.licenseConcluded) {
        const compatible = licenseChecker.isCompatible(
          pkg.licenseConcluded,
          'MIT' // Assume spell is MIT
        );
        if (!compatible) {
          warnings.push({
            severity: 'low',
            message: `${pkg.name}: License ${pkg.licenseConcluded} may be incompatible`,
            package: pkg.name
          });
        }
      }
    }

    return {
      valid: issues.length === 0,
      issues,
      warnings,
      package_count: sbom.packages.length,
      high_severity_vulns: issues.filter(i => i.severity === 'high' || i.severity === 'critical').length,
      medium_severity_vulns: warnings.filter(w => w.severity === 'medium').length
    };
  }
}
```

```typescript
// cve-scanner.ts
export interface Vulnerability {
  id: string; // CVE-2023-1234
  cvss: number;
  description: string;
  fixed_version?: string;
}

export class CVEScanner {
  async scanPackage(name: string, version: string): Promise<Vulnerability[]> {
    // Use OSV (Open Source Vulnerabilities) API
    const response = await fetch('https://api.osv.dev/v1/query', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        package: { name },
        version
      })
    });

    if (!response.ok) return [];

    const data = await response.json();

    return (data.vulns || []).map((v: any) => ({
      id: v.id,
      cvss: this.extractCVSS(v),
      description: v.summary || '',
      fixed_version: v.database_specific?.fixed_version
    }));
  }

  private extractCVSS(vuln: any): number {
    // Extract CVSS score from various formats
    if (vuln.severity?.[0]?.score) {
      return parseFloat(vuln.severity[0].score);
    }
    if (vuln.database_specific?.cvss_score) {
      return parseFloat(vuln.database_specific.cvss_score);
    }
    return 0;
  }
}
```

## 受け入れ条件
- [ ] SPDX/CycloneDX format validation
- [ ] CVE scanning via OSV API
- [ ] CVSS >= 7.0 triggers rejection
- [ ] License compatibility checking
- [ ] Validation results stored in DB
- [ ] Auto-delist on new CVE (14-day grace period)
- [ ] Tests with vulnerable packages
- [ ] Tests pass locally
- [ ] Code committed

## 依存関係
blocks: [TKT-024, TKT-161]
blocked-by: [TKT-001, TKT-021, TKT-022]

## 技術スタック
- OSV (Open Source Vulnerabilities) API
- SPDX/CycloneDX parsers
- TypeScript

## 優先度
HIGH

## 見積もり複雑度
L (Large)

## セキュリティ考慮事項
- Reject high-severity vulnerabilities (CVSS >= 7.0)
- Daily re-scan of published spells
- Grace period for patching (14 days)
- Notification to makers on new CVEs
