generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String           @id @default(cuid())
  name           String?
  email          String           @unique
  emailVerified  DateTime?
  image          String?
  githubId       String?          @unique
  role           String           @default("caster") // maker, caster, operator, auditor
  status         String           @default("active") // active, suspended, deleted

  // GDPR/CCPA Compliance
  ccpaDoNotSell    Boolean   @default(false)
  consentVersion   String?
  consentedAt      DateTime?
  deletedAt        DateTime?
  deletionReason   String?

  // Billing
  stripeCustomerId String?   @unique

  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  accounts       accounts[]
  api_keys       api_keys[]
  authenticators authenticators[]
  budgets        budgets?
  casts          Cast[]
  sessions       sessions[]
  spells         Spell[]
  reviews        Review[]
  dataTransferConsents DataTransferConsent[]

  @@index([githubId])
  @@index([stripeCustomerId])
  @@map("users")
}

model Spell {
  id               String   @id @default(cuid())
  key              String   @unique
  name             String
  description      String
  longDescription  String?
  version          String   @default("1.0.0")
  priceModel       String
  priceAmountCents Int      @default(0)
  priceCurrency    String   @default("USD")
  executionMode    String
  executionConfig  Json?    // varies by mode
  tags             String[]
  category         String?
  rating           Float    @default(0)
  totalCasts       Int      @default(0)
  inputSchema      Json?
  outputSchema     Json?
  webhookUrl       String?
  authorId         String

  // Spell Code Storage
  codeUrl      String? // R2/S3 URL to spell code (WASM, JS, Python, etc.)
  runtime      String? // wasm, node, python, deno, etc.
  codeHash     String? // SHA-256 hash for integrity verification

  // Supply Chain Security
  sbomIncluded         Boolean @default(false)
  sbomFormat           String? // spdx-json, cyclonedx-json
  sbomUrl              String?
  dependencyScanPassed Boolean @default(false)
  signatureUrl         String? // Sigstore bundle

  // Metadata
  repository   String?
  license      String?
  visibility   String   @default("public") // public, unlisted, private

  status       String   @default("draft") // draft, published, suspended, active
  publishedAt  DateTime?
  suspendedAt  DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  casts        Cast[]
  author       User     @relation(fields: [authorId], references: [id])
  reviews      Review[]
  policyViolations PolicyViolation[]

  @@unique([key, version])
  @@index([authorId])
  @@index([executionMode])
  @@index([status])
  @@index([category])
  @@map("spells")
}

model Cast {
  id           String    @id @default(cuid())
  spellId      String
  spellKey     String    // denormalized for queries
  spellVersion String    // denormalized for queries
  casterId     String
  status       String    @default("queued") // queued, running, succeeded, failed, timeout
  inputHash    String    // SHA256 of input for privacy
  mode         String?   // workflow, service
  runUrl       String?   // GitHub Actions URL or internal
  artifactUrl  String?

  // Execution
  startedAt    DateTime?
  finishedAt   DateTime?
  durationMs   Int?

  // Resource Tracking
  cpuCycles            BigInt?
  memoryPeakBytes      BigInt?
  networkBytesSent     BigInt?
  networkBytesReceived BigInt?

  // Billing
  costCents      Int     @default(0)
  billingStatus  String? // pending, charged, refunded

  // Region
  region String?

  // Idempotency
  idempotencyKey String @unique

  // Legacy fields
  githubRunId      String?
  githubRunAttempt Int?
  errorMessage     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  caster    User     @relation(fields: [casterId], references: [id])
  spell     Spell    @relation(fields: [spellId], references: [id])
  review    Review?

  @@index([casterId])
  @@index([createdAt])
  @@index([spellId])
  @@index([spellKey])
  @@index([status])
  @@map("casts")
}

model Review {
  id        String   @id @default(cuid())
  castId    String   @unique
  spellId   String
  userId    String
  rating    Int
  comment   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  cast      Cast     @relation(fields: [castId], references: [id], onDelete: Cascade)
  spell     Spell    @relation(fields: [spellId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([spellId])
  @@index([userId])
  @@index([createdAt])
  @@map("reviews")
}

model accounts {
  id                String  @id
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  users             User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model api_keys {
  id         String    @id @default(cuid())
  userId     String
  name       String
  keyHash    String    @unique // Hashed value for security
  keyPrefix  String    // First 8 chars for display (sk_live_xxx...)
  scopes     String[]  // spell:publish, cast:invoke, ops:deploy, audit:read
  lastUsedAt DateTime?
  status     String    @default("active") // active, revoked
  expiresAt  DateTime?
  revokedAt  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  users      User      @relation(fields: [userId], references: [id])

  @@index([keyHash])
  @@index([userId])
}

model authenticators {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?
  users                User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}

model budgets {
  id                String   @id @default(cuid())
  userId            String   @unique

  // Caps
  monthlyCapCents   Int?     // Monthly spending cap
  totalCapCents     Int?     // Total lifetime cap

  // Usage
  currentMonthCents Int      @default(0)
  totalCents        Int      @default(0)

  // Period
  periodStart       DateTime @default(now())
  periodEnd         DateTime?

  // Status
  capExceeded       Boolean  @default(false)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  users             User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

model IdempotencyKey {
  id             String   @id @default(cuid())
  key            String
  endpoint       String
  scope          String
  requestHash    String?
  responseStatus Int?
  responseBody   Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([key, endpoint, scope])
  @@map("idempotency_keys")
}

model sessions {
  id           String   @id
  sessionToken String   @unique
  userId       String
  expires      DateTime
  users        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model verification_tokens {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PolicyViolation {
  id            String   @id @default(cuid())
  spellKey      String
  spellId       String
  castId        String?

  violationType String   // network, fs, timeout, memory
  details       String
  severity      String   // low, medium, high, critical

  createdAt     DateTime @default(now())
  spell         Spell    @relation(fields: [spellId], references: [id])

  @@index([spellKey])
  @@index([spellId])
  @@index([createdAt])
  @@map("policy_violations")
}

model DataTransferConsent {
  id              String   @id @default(cuid())
  userId          String

  transferType    String   // eu_us, us_jp, etc
  mechanism       String   // scc, adequacy, dpf
  consentVersion  String
  consentedAt     DateTime @default(now())

  user            User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@map("data_transfer_consents")
}
